# AFML 总结
主要记录一下能够对我的工作产生改进的地方

## 数据预处理
1. tick级别的数据的聚合：Dollar or Volume or Event-driven bars 可以尝试，不过一般就是使用time bar
2. 分红 or 派息等问题的处理：the ETF trick
3. 期货换月的处理：将换月的收益从价格序列中减去
4. 抽样：不能直接将全部的数据作为样本放入ML model中，因为这样会导致预测效果很差。使用cumsum filter: 只抽取异常现象累积到一定量的样本
5. labelling: 给样本打标签，有多种方法：<br>
   - 直接使用未来收益率，但是因为time bar的收益率的波动率不是稳定的，
一般使用波动率调整的未来收益率或者使用使用volume or dollar bar。 
   - triple-barrier method：设置了止盈止损和时间三个barrier
   - meta-labelling
6. sampling weight：主要解决样本的标签具有时序上的相关性，不满足很多模型对于样本之间iid的假设这个问题。
7. 差分：差分带来平稳但是让序列失去时序上的预测能力。那么考虑小数阶差分：既保证了数据的平稳性，又保留了大部分数据的预测能力。
具体做法上，使用ADF test，找到使得序列通过ADF检验（说明序列平稳）的最小分数d

## 模型
1. bagging模型相比boosting更加擅长解决过拟合问题，更加推荐使用在金融数据上，因为金融问题一般受到过拟合影响。
2. 样本冗余导致随机森林模型容易过拟合，可以有多种解决方法：见书p98
3. bagging模型如果无法承担过大的样本量（比如SVM），那么可以对基模型使用早停，然后再利用将多个模型bagging在一起降低方差。\

## 交叉验证
1. 样本之间的相关性会导致普通的k折交叉验证失效，因为测试集中用到了训练集的信息，见书p107。可以采取Purge和embargo两种方法。
不过我之前使用的训练就是简单的滚动训练，没有用到k折交叉验证。可以尝试使用k折交叉验证。
2. 网格或随机搜索交叉验证可以用来调整模型的超参数。有如下几个注意点。
   - 使用sklearn中GridSearchCV的cv参数需要自定义为PurgedKFold方法。
   - meta-labelling的情况下，GridSearchCV的scoring参数建议设置为f1
   - 非meta-labelling的情况下，GridSearchCV的scoring参数建议设置为neg_log_loss，见书p134
   - 对特定模型，遍历参数的范围分布可以使用log-uniform，见书p132


## 回测
1. 特征重要性的研究比回测结果更加重要。我们可以使用Mean Decrease Impurity、Mean Decrease Accuracy还有Single Feature Importance
等手段衡量特征重要性。特征重要性有助于我们了解ML这个黑箱。
2. 即使回测框架完美，不存在数据泄露等问题，但是因为在同样的path下一遍又一遍地测试模型，也会产生selection bias（false discovery）。
3. backtest的目的在于丢弃不好的模型，而不能用于改良模型。因为一旦改良模型，就会陷入overfit，
而且因为常规WF backtest的path只有一条，所以更加容易过拟合。这里本质是因为不能使用训练集（历史数据）调参。
4. 可以使用PBO衡量从多个因子中选择一个最佳因子这个过程中，出现过拟合的概率。
5. 使用交叉验证CV进行回测，可以解决很多的WF方法的缺点。首先我们要明确CV的目的：不是为了查看历史数据上策略的真实表现，
而是查看策略在未知情形下的表现。这就是所谓情形模拟，可以帮助降低过拟合。不过CV也只有一条path，代表每次CV只能生成一个（拼接后的）回测结果。
6. 使用CPCV方法，可以改善CV。CPCV结合了前面章节的purge和embargo方法，同时通过在每次交叉验证的时候给测试集安排大于一份的分割后的子样本，见书p165。
7. 直接在模拟数据上回测，也可以降低过拟合问题，因为保证了策略不会因为过拟合于某一个特定历史时期上的数据。
具体实现方式是先假定价格的分布并且估计分布参数，再回测。见书p169。
8. 我们可以推导出年化sharpe、交易频率和胜率之间的关系（或许可以写几个简单的关系式函数，帮助快速判断）。 
9. 策略的风险可以通过策略的sharpe对胜率的敏感程度衡量。也可以求出使得策略的sharpe大于等于目标所要求的最低胜率来衡量。

## 因子构造
1. bet sizing指的是我们的仓位大小，对时序策略可以理解为因子值。这里的问题是我们有时候使用的ML模型是一个分类器（比如meta-labelling），
那么我们需要将分类器的结果转换为因子值（仓位）。具体方法是使用cdf，转换为-1到1之间的因子值，见书p142。这样操作后，我们在每个bar都有一个bet size。
但是每个bet 都有一段持续时间。对每个时刻，我们需要将该时刻上的所有bet取平均值。然后，我们还可以进行仓位离散化操作。见书p144。我们还可以根据
价格变动动态调整bet size。
2. 仓位离散化 + 扣费 这套组合可能可以更好地改善连续型因子的费后sharpe。
3. 除了自己的一些因子可以作为模型的自变量，我们也可以通过一些经典的特征作为模型自变量。
   - structural break特征：我们可以利用识别structural break的方法来构造特征。
   - entropy features：利用信息熵构造特征。
   - Microstructure features：基于微观结构的特征，例如bid-ask spread的评价指标、市场流动性的衡量指标λ、PIN等都可以作为特征。
